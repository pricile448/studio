
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper function to check if the requester is an admin
    function isAdmin() {
      return exists(/databases/$(database)/documents/admins/$(request.auth.uid));
    }

    // Admins can read/write all documents
    match /{document=**} {
      allow read, write: if isAdmin();
    }

    // Rules for the 'users' collection
    match /users/{userId} {
      // Any authenticated user can create their own user document upon signup
      allow create: if request.auth.uid == userId;
      
      // Users can read their own profile
      allow read: if request.auth.uid == userId;
      
      // Users can update their profile, with specific rules for different scenarios
      allow update: if request.auth.uid == userId && (
        // Scenario 1: KYC Submission
        // Allows updating from 'unverified' to 'pending' and adding documents.
        (
          resource.data.kycStatus == 'unverified' &&
          request.resource.data.kycStatus == 'pending' &&
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['kycStatus', 'kycSubmittedAt', 'kycDocuments'])
        ) ||
        // Scenario 2: Standard profile update (cannot change critical fields)
        (
          !request.resource.data.diff(resource.data).affectedKeys().hasAny([
            'uid', 'email', 'accounts', 'transactions', 'kycStatus', 'cardStatus', 'iban', 'bic'
          ])
        ) ||
        // Scenario 3: Requesting a physical card
        (
           resource.data.cardStatus == 'none' && request.resource.data.cardStatus == 'requested' &&
           request.resource.data.diff(resource.data).affectedKeys().hasOnly(['cardStatus', 'cardType', 'cardRequestedAt'])
        ) ||
        // Scenario 4: User freezing/unfreezing their own physical card
        (
          resource.data.physicalCard.suspendedBy != 'admin' &&
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['cardStatus', 'physicalCard'])
        ) ||
         // Scenario 5: User managing virtual cards (add, freeze, delete)
        (
          request.resource.data.diff(resource.data).affectedKeys().hasAny(['virtualCards', 'hasPendingVirtualCardRequest', 'virtualCardRequestedAt'])
        ) ||
        // Scenario 6: User managing beneficiaries
        (
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['beneficiaries'])
        ) ||
        // Scenario 7: User managing budgets
         (
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['budgets'])
        ) ||
        // Scenario 8: User uploading documents
        (
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['documents'])
        ) ||
        // Scenario 9: User updating notification preferences
         (
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['notificationPrefs'])
        ) ||
        // Scenario 10: User updating inactivity timeout
         (
           request.resource.data.diff(resource.data).affectedKeys().hasOnly(['inactivityTimeout'])
        )
      );
    }

    // Public read for billing config
    match /config/billing {
      allow read: if request.auth != null;
    }
    
    // Rules for chat
    match /chats/{chatId} {
      allow read, write: if request.auth.uid in resource.data.participants;

      match /messages/{messageId} {
        allow read, create: if request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants;
        
        // Allow a user to update their own message only to mark it as deleted for them
        allow update: if request.auth.uid == resource.data.senderId &&
                       request.resource.data.diff(resource.data).affectedKeys().hasOnly(['deletedForUser']) &&
                       request.resource.data.deletedForUser == true;
      }
    }
  }
}
