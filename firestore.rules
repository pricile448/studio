
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // ==================
    // Helper Functions
    // ==================
    
    function isUserAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isUserAuthenticated() && request.auth.uid == userId;
    }
    
    function isAdmin() {
      // La vérification d'existence est une lecture, donc il faut une règle 'read' sur /admins/{adminId}
      return isUserAuthenticated() && exists(/databases/$(database)/documents/admins/$(request.auth.uid));
    }
    
    // ==================
    // Collections
    // ==================

    match /users/{userId} {
      allow read: if isOwner(userId) || isAdmin();
      allow create: if isOwner(userId);
      
      // Règle 1: L'utilisateur peut mettre à jour ses informations de base.
      allow update: if isOwner(userId) && request.resource.data.keys().diff(resource.data.keys()).hasOnly(['firstName', 'lastName', 'phone', 'dob', 'address', 'city', 'postalCode', 'residenceCountry', 'profession', 'salary', 'pob', 'nationality', 'photoURL', 'notificationPrefs', 'inactivityTimeout']);
      
      // Règle 2: L'utilisateur peut gérer sa liste de bénéficiaires.
      allow update: if isOwner(userId) && request.resource.data.keys().diff(resource.data.keys()).hasOnly(['beneficiaries']);

      // Règle 3: L'utilisateur peut ajouter des documents.
      allow update: if isOwner(userId) && request.resource.data.keys().diff(resource.data.keys()).hasOnly(['documents']) && request.resource.data.documents.size() > resource.data.documents.size();
      
      // Règle 4: L'utilisateur peut demander/gérer ses cartes. La logique fine (blocage par admin) est gérée par les fonctions backend sécurisées.
      allow update: if isOwner(userId) && (
        request.resource.data.keys().diff(resource.data.keys()).hasOnly(['cardStatus', 'cardType', 'cardRequestedAt']) ||
        request.resource.data.keys().diff(resource.data.keys()).hasOnly(['hasPendingVirtualCardRequest', 'virtualCardRequestedAt']) ||
        (request.resource.data.keys().diff(resource.data.keys()).hasOnly(['cardStatus', 'physicalCard']) && resource.data.physicalCard.suspendedBy != 'admin') ||
        request.resource.data.keys().diff(resource.data.keys()).hasOnly(['virtualCards'])
      );
      
      // Règle 5: L'utilisateur peut soumettre son KYC (passage de 'unverified' à 'pending').
      allow update: if isOwner(userId) && request.resource.data.kycStatus == 'pending' && resource.data.kycStatus == 'unverified' && request.resource.data.keys().diff(resource.data.keys()).hasOnly(['kycStatus', 'kycDocuments', 'kycSubmittedAt']);
      
      // Règle 6: Un utilisateur peut ajouter une transaction si et seulement si elle est de type 'virement sortant' et a le statut 'en attente'.
      // Cela empêche un utilisateur de modifier son propre solde.
      allow update: if isOwner(userId) 
                      && request.resource.data.keys().diff(resource.data.keys()).hasOnly(['transactions'])
                      && request.resource.data.transactions.size() == resource.data.transactions.size() + 1
                      && request.resource.data.transactions[request.resource.data.transactions.size() - 1].status == 'pending'
                      && request.resource.data.transactions[request.resource.data.transactions.size() - 1].type == 'outgoing_transfer';
    }
    
    match /admins/{adminId} {
      allow read: if isAdmin();
      allow write: if false; 
    }
    
    match /chats/{chatId} {
      // Seuls les participants peuvent lire ou écrire dans la conversation.
      allow read, write: if isUserAuthenticated() && request.auth.uid in resource.data.participants;
      
      match /messages/{messageId} {
        allow read: if isUserAuthenticated() && request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants;
        allow create: if isUserAuthenticated() && request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants;
        // Permet à l'utilisateur de "soft delete" son propre message.
        allow update: if isOwner(request.resource.data.senderId) && request.resource.data.deletedForUser == true && resource.data.deletedForUser == false;
        allow delete: if false; // Suppression physique interdite depuis le client.
      }
    }
  }
}
