
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    function isUpdatingOwnProfile() {
      let allowedFields = [
        'firstName', 'lastName', 'phone', 'dob', 'pob', 'nationality',
        'residenceCountry', 'address', 'city', 'postalCode', 'profession',
        'salary', 'notificationPrefs', 'inactivityTimeout'
      ];
      // Check that only allowed fields are modified
      return request.resource.data.diff(resource.data).affectedKeys().hasOnly(allowedFields);
    }
    
    function isRequestingCard() {
      return request.resource.data.cardStatus == 'requested' &&
             resource.data.cardStatus == 'none' &&
             request.resource.data.cardRequestedAt == request.time &&
             request.resource.data.diff(resource.data).affectedKeys().hasOnly(['cardStatus', 'cardRequestedAt']);
    }

    function isAddingVirtualCard() {
      let oldCards = 'virtualCards' in resource.data ? resource.data.virtualCards : [];
      let newCards = request.resource.data.virtualCards;
      
      if (newCards.size() != oldCards.size() + 1) {
        return false;
      }
      if (oldCards.size() > 0 && !newCards[0:oldCards.size()].isEqualTo(oldCards)) {
        return false;
      }

      let newCard = newCards[newCards.size() - 1];
      // Validate the new card's structure and values
      return newCard.keys().hasAll(['id', 'type', 'status', 'name', 'number', 'expiry', 'cvv', 'limit', 'isFrozen', 'createdAt']) &&
             newCard.id is string && newCard.id.matches('^vc_.*') &&
             newCard.type == 'virtual' &&
             newCard.status == 'active' &&
             newCard.name == 'Carte virtuelle' &&
             newCard.number is string &&
             newCard.expiry is string &&
             newCard.cvv is string &&
             newCard.limit == 1000 &&
             newCard.isFrozen == false &&
             newCard.createdAt is timestamp &&
             // Allow for some clock skew between client and server (2 minutes)
             newCard.createdAt.toMillis() > request.time.toMillis() - 120000 &&
             newCard.createdAt.toMillis() < request.time.toMillis() + 120000 &&
             request.resource.data.diff(resource.data).affectedKeys().hasOnly(['virtualCards']);
    }

    function isDeletingOwnMessage(chatId, messageId) {
      let message = get(/databases/$(database)/documents/chats/$(chatId)/messages/$(messageId));
      return message.data.senderId == request.auth.uid &&
             request.resource.data.deletedForUser == true &&
             request.resource.data.diff(resource.data).affectedKeys().hasOnly(['deletedForUser']);
    }
    
    match /users/{userId} {
      allow read, create: if request.auth.uid == userId;

      allow update: if request.auth.uid == userId && (
        isUpdatingOwnProfile() || 
        isRequestingCard() ||
        isAddingVirtualCard()
      );
    }
    
    match /admins/{adminId} {
      allow read: if request.auth.uid == adminId;
    }
    
    match /chats/{chatId} {
      // Users can only interact with chats they are a part of
      allow read, create, update: if request.auth.uid in resource.data.participants;
      
      match /messages/{messageId} {
        // Users can read/create messages in chats they participate in
        allow read, create: if get(/databases/$(database)/documents/chats/$(chatId)).data.participants.hasAny([request.auth.uid]);
        // Users can only "soft delete" their own messages
        allow update: if isDeletingOwnMessage(chatId, messageId);
      }
    }
  }
}
